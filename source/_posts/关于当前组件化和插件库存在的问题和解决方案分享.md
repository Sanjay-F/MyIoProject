title: 关于当前公开的组件化方案存在的问题与解决方案探索

date: 2019-02-22 23:14:46

tags: [android,组件化,插件化]

categories: android 

------------------------------------------


本文就目前公开文章讨论的 组件化方案 和 插件库 存在的问题，

和这些方案就组件化过程没提到的一些实际问题，

结合自己在项目做出的改进方案做些记录，分享。
 

<!--more-->

# 起航



##  四处乱跑的AppRuntime
![](https://i.imgur.com/B514Xbr.png)    

大部分公开的方案使用接口的方式的，都是有个第三者（AppRuntime），然后各个基础库的服务往他注册，或者通过它来调用。
模块间的交互问题是用上帝模块（如APP模块，其依赖所有模块）来统一向基础的第三方模块AppRuntime注册服务.然后业务再通过AppRuntime的getSercvie()获取服务。


例如下面这样的：
![](https://i.imgur.com/V6LlXu1.png)

所以在项目代码中会有大量的类似下面的代码：

    AppRuntime.getService(xxxInterface.class).doSomeThing()；

这个还可以忍受，不能忍受的还在app模块的初始化时候，有大量的注册服务的逻辑

	    AppRuntime.registerService(xxxInterface.class,xxxImpl.class);
		AppRuntime.registerService(xxxInterface.class,xxxImpl.class);
		AppRuntime.registerService(xxxInterface.class,xxxImpl.class);
 

通过往共同依赖的第三方模块注入服务后，模块间可以达到良好的解耦合，面向接口编程。
不直接引用具体的实现。

然后这些服务都会有个基础的服务类，类似下面这样，从而好被循环的调用初始化逻辑。
			
		public interface IService {
		
		    void onLoad(Context context, Config config);
		
		    void onUnload();
		}
简单理解为，这个把以前我们在application的onCreate时候做的一堆类似初始化xxx的逻辑，下放到了各个xxxService里面去了。


**举个栗子**

例如我们的bugly会想我们传账号的id，从而让我们好跟踪某个crash是谁的,这就让bulgy需要在login后面初始化。
别的服务初始化时候，可能会打log，然后我们的log是做了slf4j的库等来做的，所以需要先于它初始化

	public class BuglySercie{

		void onLoad(Context context, Config config){

			int uid= getService(Login.class).getUid;

			setUid(uid)
		}

	}

**但上面的方式有两个大的问题没解决好。**

- **Service间初始化顺序问题**。
服务相互依赖后，必然存在初始化顺序问题，假设A依赖B的Service业务能力，那么在初始化A前，需要先往AppRuntime注册B，从而保证A初始化时，能正确的拿到B。 
一开始可以通过手工的在注册时候显式的排顺序去做，但随着注册的服务从几个，涨到几十个后，其复杂的依赖关系已经无人能知晓，后续再增加服务，`完全有可能导致循环依赖情况，并且很难被及时发现并解决。`

- **增删业务不便。**
做组件化，经常聊的一个问题就是 组件单独调试和联调等问题。
	
	单独的Application启动器来做组件单独调试：	
	在平时的开发过程，开发人员只想对自己的新功能做测试，所以会想只单独注册注册的Service调试，并不像现在这样一次性注册所有，然后把所有业务代码都编译进去，从而拖慢编译速度。按照这方案 独立的application来启动或者别的联调方案也好，你都不可避免要把这些初始化语句做个`增删`，从而保留只需要的那么几个服务。
	
	重要的是随着业务膨胀，后期完全可能存在做极速版app或者做插件app的问题，这时候也需要对业务做裁剪，保留功能，从而缩包。
	只要app一做大，注册的服务一多达到几十个，目前我们的业务已经膨胀到近30个了，那以后完全是开发不友好的。

	灵活性欠佳，我们希望开发同学不要再去关注这样的细节了。

目前就自己看到的公开文章，只有`微信`的解决方案是相对完整的。具体可看这篇文字[微信Android模块化架构重构实践](https://mp.weixin.qq.com/s/6Q818XA5FaHd7jJMFBG60w)

但不得不说，如果微信每次启动都需要走一遍这个流程，做初始化的配置，生成一张依赖关系树状图，拓扑排序，然后执行。
类似的启动初始化逻辑，估计也会导致了目前每次微信启动速度变得越来越慢。重要的是这些都变成了运行时的了，没办法在编译时完成。


## 解决方案探索

我们希望有更好的方案，能否满足一下几点：

1.	自动注册服务。类似registerService()语句很冗余，能否省去，程序自动知道我这个类就是服务，然后自动帮我写注册，从而也间接解决前面提到的`问题2，增删业务不便`。

2.	编译时确定注册逻辑。 我们能否通过每个服务告诉系统自己需要依赖的Service，从而编译时候就清楚整个依赖关系，然后生成有向无环图，接着自动根据依赖关系排序初始化。这样就不用每次启动时候像微信那样跑一遍流程，毕竟这个结果每次都一样，没必要每次启动都执行。 
 
3.	编译时输出服务依赖注册关系。随着业务膨胀，没人能完全知道整个服务的初始化顺序，有时候定位问题需要知道他们之间的关系，所以我们想能否输出类似依赖关系树图的东西，让开发人员能够看到整体的服务关系。类似于Aroute也可以打印路由关系一样。

4. 服务自动注入能力。不再需要手动的去写那堆`AppRuntime.getService(xxxInterface.class)`的冗余逻辑。做到像Dagger一样的，自动给我注入。

		public class MainActivity extends AppCompatActivity {
	
		    @Inject
		    IPlayService playService;
		
		    @Override
		    protected void onCreate(Bundle savedInstanceState) {
		        super.onCreate(savedInstanceState);
		        setContentView(R.layout.activity_main);
				playService.playSomeThing(url);
		    }
		}

5. 进程控制。
经常会有些业务逻辑能力是跑在另外的某个进程的，例如有些会把web的能力单独弄成一个进程，保证crash了也不会影响，
或者把下载服务能力等弄成一个单独的进程。为此我们需要把注册服务在进程上做区分。


6. 服务的漏注依赖关系问题。  
这是一个相对现实的问题，本来我们的服务是有依赖某个服务的，但它并不申明，但实际代码中就是调用了，这个需要做兜底检测逻辑。
这个没办法通过代码的应用关系等来做判断，因此只能靠开发自动手动注册和检测逻辑来做。
具体场景会在后面再提到做说明，从而更好的理解这个问题。


**综上，我们想优化后的方案能是这样的：**

- 首先，我们可以在业务的服务接口声明自己需要依赖的Service，在编译时候就给我生成依赖关系树图，提前判断循环依赖等问题。 
- 接着，如果是DAG即有向无环图，那就不存在环，用拓扑排序算法，将图变成一个数组，从而算出他们正确的注册执行顺序。
- 然后，利用这个正确的初始化逻辑的数组，去自动生成注册代码，避免我们手工注册服务。当然也输出这个结果给开发人员看。
- 最后，自动往添加@inject注解的变量赋值对应的服务实现类。


对于上面的方案想法，相对业界目前公开的方案来说，相对更好，做到了编译时处理，自动注入服务，同时不影响编译时性能，把前面提到的1-5个问题得到解决。


在经过长时间的尝试之后，终于探索出了一个全新的解决方案，且满足以上的所有想法。
这个方案不需要用很深的黑科技，但确实是一个新的突破，属于相对综合的更优方案。

## 解决方案

整体流程图：
![](https://i.imgur.com/vlnF2Rl.png)

1. 生成注解配置。我们在业务写好对应的服务注解等后，在编译时候通过`AnnotationProcessor`注解处理器，会生成一个对应的依赖关系文件`FALCO_CONFIG`。

2. 生成注册服务类和自动注入服务。 接着FalcoPlugin，一个gradle的插件，会在执行JavaC前解析这个文件，做生成依赖树图，如果是DAG就拓扑排序然后生成一个正确的依赖关系数组，接着将这个数组生成一个`AppAutoRegisterService.class`文件到项目代码中去，这部分就是parseFileToDag()->TopoSort()->wirteResultToJavaFile()做的事情。
   与此同时，会把代码中加了@AutoInject注解的变量，自动插入赋值语句。

	**这么做的好处就是可以省去xxx.bind(this)操作。**你看ButterKnife，Arouter等框架，就存在大量的类似的xxx.bind(this)的操作，背后是为了执行对应的赋值操作，现在可以省了。此处应有掌声。

3. 加载服务LoadAutoRegiser()。启动时加载这个`AppAutoRegisterService.class`生成的类，好完成我们的注册服务。




通过这个流程，我们达到了期待的效果，很开心。



## 一些细节的解释

1. 关于声明依赖注解的说明

		@AutoRegisterService(value = {IFeedReplyUIService.class},
	        dependsClass = {IUserInfoService.class, IRelationService.class, ITopicService.class},
	        processName = {PROCESS.WEB})
		public class FeedReplyUIService extends FeedReplyService implements IFeedReplyUIService {
	    
		    @AutoInject
		    ILogService iLogService;
		}
在项目代码中，需要手动写一个`@AutoRegisterService`注解，同时声明自己实现的服务在value=xxx，如果你依赖了某个服务，需要在dependsClass={}写上依赖类，对于需要跑在特定Process的需要加多processName = {}。

	这里说明下为何还需要手动的去声明下依赖的服务类，而不是自动发现依赖关系。**原因很简单，性价比低，而且很难做到。**
假设A类需要cClass的服务先初始化，然后背后的调用链条是这样的：

	在初始化A时候，在初始化代码时候，可能调用bClass.init（），然后在这个init（）里面，可能调用了cClass.doSomeThing()。类似如此的嵌套后，很难简单快速的得到A
	
	初始化后需要的是谁。特别是在如果还存在运行时的判断条件后，那就更不好做判断了。
	
			if(debug){
				cClass.doSomeThing()
			}else{
				dClass.doSomeThing()
			}

	因此对于依赖关系我们最后选择叫给了开发同学，自己去做这件事情。

2.  服务的漏注依赖关系问题
在前面的`解决方案探索`时候，我们就提到这个服务的漏注依赖关系问题问题。
因为刚才说了，现在我们把依赖关系交给开发，让他自己去做了。但在实际开发过程中发现，完全可能在相对复杂的调用链路中，小明同学加多了别的服务的调用，然后没在注解上显示的去声明多这个依赖的情况，所以就显得尴尬了。

	为何这么说了，因为在用这个方案的实践中，有时会**偶现依赖关系顺序的crash问题**。

	最后跟下来就是因为在  A中的某个初始化的调用链路中加多对C的调用，然后并没有在A中显示的声明对C的调用，这导致了两者在排序的时候，有时是A在前面，有时是C在前面先被初始化。为何会出现这个排序前后的跳变，而不是固定的关系呢，因为他们是通过 注解处理器 处理后，往`FALCO_CONFIG`文件插入注解的信息的，然后再作为输入源给图做排序，因此也就存在先后了。

	而且因为支持增量编译，所以存在着修改 或者 删除某个Module，那么只针对这个模块做增量构建，然后插入或者 删除某个module对应依赖关系的配置 到`FALCO_CONFIG`里面去。

	**解决方案：**
	为了处理好这个问题，最后做多了运行时的依赖关系检测逻辑，如果存在循环依赖，或者依赖了别的服务，但是没有显示的声明的话，那就做报错和弹Toast提醒。经过一段时间的迭代后，整体对应的问题都能被提前发现了。


 

# 小结

以上是针对于服的注册，调用与注入的一个讨论，篇幅比较长了，就先停笔，后面再讨论关于
1. 下沉的基础库管理，我们会把大量基础库做下沉，例如下载库，账号等。这块的管理想谈一下。
2. 开发业务组件规范，后续我们业务组件化后，需要有个规范，避免腐化。
3. 切换测试环境与生产环境配置 ，我们的包需要有不同的配置，这个好理解，但都没怎么说到这块，也打算聊下这个。 
 
我认为通过上面的方案，我们让对不同的 。