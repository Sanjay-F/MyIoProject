title:  安卓性能系列2---优化内存
date: 2016-05-23 22:45:46
tags: [android,animator,property]
categories: android

------------------------------------------

针对内存优化，打算开两篇，一篇为介绍工具篇，利用现有的工具，来帮助我们更好的解决问题。
在有一定的实践经验后，再另外写一篇，介绍些原理，了解内存模型等内容，这有助于我们写出更好的程序。
先使用，再说原理，我认为这样的安排，才是符合人类认知的，我们总是先接触，对事物有个大概的认知，然后深入了解后，才会做出总结和归纳演绎等，把内容抽象化，得出些结论性的内容。再利用理论来更好的指导我们工作。

本次涉及到的工具有Android Studio自带的Memory Monitor，然后是些adb命令。
最后来看下Deep Memory Profile。

<!--more-->

 
 

## Memory Monitor

现在的Android Studio自带了不少工具，其中Android Monitor就非常好用，可以帮助我们快速的定位问题，这相对以前快捷易用不少，而且图形化。
谷歌有意识的把很多软件的功能集成到它的这个Android Studio IDE中来，例如Sdk Manager现在变成了设置中的一项了，不再是单独的直接另外打开一个窗口，虽然在底部有一个选择可以让我们继续看到原来的界面效果。原本在Android Device Monitor的内容，也部分被搬到了底部的Android Monitor去了。

好了，废话不多说，我们进入主题。

 
![enter image description here](http://7xl9zd.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160527143645.png)

> Memory  Monitor可以帮助我们实时的看下现在的内存情况是怎样的，如上图所示，深蓝色是我们Allocated,然后透明的浅色是目前还剩余的大小。
> 有需要我们还可以dump内存情况来看，只需要点击`按钮2` 另外还可以记录跟踪，这时候点`按钮3`，这样就可以从我们点击的时刻开始记录。
> 同时我们可以主动的触发GC。只需要点击`按钮1`。



## Demo
以上就是他的基本使用点，在进一步介绍前，我们来写点代码，作为后面讲解用：
假设我们的app只有一个按钮，点击后就会去调用`onBugClick`函数


	public class MainActivity extends Activity {
	    private static final String TAG = MainActivity.class.getSimpleName(); 	     
	    private ArrayList<Object> ourBugBeanLists;
	
	    @Override
	    protected void onCreate(Bundle savedInstanceState) {
	        super.onCreate(savedInstanceState);
	        setContentView(R.layout.activity_main);
	 
	    }	 
	
	    public void onBugClick(View view) {	
	        ourBugBeanLists = new ArrayList<>();
	        for (int i = 0; i < 100; i++) {
	            BugBean bugBean = new BugBean();
	            bugBean.setIndex(i);
	            ourBugBeanLists.add(bugBean);
	        }
	        Log.e(TAG, "onBugClick() size=" + ourBugBeanLists.size());
	    }
	}
 
接着是我们的bean

	public class BugBean {

	    private List<String> data;
	    private int index;
	    private String name;
	
	    public BugBean() {
  	      // 为了能在内存上造成一个起伏，我们的直接来个3000个String
	        data = new ArrayList<>(3000);
	    }
	    
	    ...//getter & setter 
	}

在这样的基础上，接着我们开始实际的使用，我们先看下下面的效果图，在大约启动后的第**46**秒的时候，我点击哪按钮，触发了onBugClick函数，效果很好，内存直接多了差不多1MB的大小。


![enter image description here](http://7xl9zd.com1.z0.glb.clouddn.com/memoryQQ%E6%88%AA%E5%9B%BE20160527150146.png)


假设我们实际不知道上面的代码内容，只是一般的在用APP，然后看到整个界面突然内存飞起来了， 
然后我们想知道为何增加了这么多，而且多出来的内容实际是什么。

不过由于我们没有点击**按钮3**去跟踪，所以我们就先来直接dump Java Heap看下现在内存是怎样的，那些类用了内存，做个大概的推断。点击后弹出来的界面大致这样子的。


![enter image description here](http://7xl9zd.com1.z0.glb.clouddn.com/memoryQQ%E6%88%AA%E5%9B%BE20160527160941.png)

[点击查看大图](http://7xl9zd.com1.z0.glb.clouddn.com/memoryQQ%E6%88%AA%E5%9B%BE20160527160941.png)

## 面板介绍 

 现在我们来解释下顶部各栏的意思是什么：
 
|列名|描述|
| -----|----|   
|Class Name	|The Java class responsible for the memory.
|Total Count	|Total number of instances outstanding.
|Heap Count	|Number of instances in the selected heap.
|Sizeof	|Size of the instances (currently, 0 if the size is variable).
|Shallow Size|	Total size of all instances in this heap.
|Retained Size|	Size of memory that all instances of this class is dominating.
|Instance	|A specific instance of the class.
|Reference Tree	| References that point to the selected instance, as well as references pointing to the references.|
|Depth	| The shortest number of hops from any GC root to the selected instance.
|Shallow Size	| Size of this instance.
|Dominating Size | Size of memory that this instance is dominating.|
 
这里简单的说下，左上角可以版主我们整理下面的Class Name面板的排序情况。 
包括App Heap和Zygote Heap两种，右边的有Package Tree View 和Class List View两种。

如果我们选中了Class List View，可以快速的看现在各种类的使用情况。 
这个可以给我们一个依据，看现在是什么类霸占了较多的内存，一般估计是图片 ^_^。


最右边有一个`Analyzer Task` 面板，提供对Activity是否泄漏和字符串重复的检测。同时有对应的检测结果和解释可以看。这比生成了快照，然后跑去**MAT**查看是否感觉便捷多了呢？
虽然现在检测泄漏我用`LeakCanary`去做，不怎么用MAT了，毕竟用起来还是相对麻烦些。

 **Tips:**

1. 另外想提的是，这里dump的文件是不能给MAT直接用的，还需要装换下格式。
步骤如下： 
In the Captures window, right-click a heap snapshot file and select Export to standard .hprof.
In the Convert Android Java Heap Dump dialog, specify a filename and click OK.

2. Dump文件已经自动保存好了，如果你后面如果还要看这些信息，可以点击Captures，(View > Tools Windows > Captures.) 

 


## 静态寻找---Dump Java Heap

### 按Class List View
按照`Retained Size`排序，发现ArrayList占用了不少。
计划着我们看左边的**Instance**面板，也是按照`Retained Size`排序，点击开头那个最大的，
在底部的**Reference Tree**，我们看到是在`MainActivity`里面的`ourBugBeanLists`占用了很大空间。
这样我们可以某种程度怀疑就是这家伙导致内存上升了，然后去对应的界面看对应的代码是怎么回事。

不过有时候可以直接选对应的Activity，因为内存的增加，一般都是在界面上做了些什么操作导致的，那么我们去选中对应的Activity会是一个不错的方案。

例如像上面那样，直接选MainActivity会好些，因为当程序大了，ArrayList会在很多地方被调用，直接看会像右边那样有一大堆的Instance，如果大小差不多，要排查就不容易了。

当然以上只是提供一个思路，具体问题，灵活处理，以上只是基本套路。

![enter image description here](http://7xl9zd.com1.z0.glb.clouddn.com/memoryQQ%E6%88%AA%E5%9B%BE20160527165232.png)


### 按Package Tree View

除了上面的按类排序看，我们可以按照Packages看，这个我自己比较喜欢的目录树结构，就像我们的项目结构一样，我们可以清晰的看到整体的情况。

![enter image description here](http://7xl9zd.com1.z0.glb.clouddn.com/memoryQQ%E6%88%AA%E5%9B%BE20160527171130.png)

根据上图，我们发现的是在com包里面有不少内容，一层层看下去，到了我们的MainActivity用了很多，同时在右边的Instance面板，看到主要是我们的`ourBugBeanLists`霸占了1204560 ，约1MB。


### 小结

以上可以帮助我们快速的看内存的情况，不过没有调用的信息，我们不知道到底是哪些函数的调用导致了内存的增加，虽然根据对应的界面的对应变量信息，我们也可以挺快的定位到问题了。
 

##  Why Look at the Java Heap?

然后附加个官方说的，为何要看Java Heap

The Java heap display does the following:

- Shows snapshots of a number of objects allocated by type.
-  Samples data every time a garbage collection event occurs naturally or is triggered by you.
- Helps identify which object types might be involved in memory leaks.

However, you have to look for changes over time yourself by tracking what's happening in the graph.

The HPROF Analyzer finds the following **potential issues**:

-  All destroyed activity instances that are reachable from garbage collection roots.
- Where the target program has strings that repeat values.

A dominator is at the top of a tree. If you remove it, you also remove the branches of the tree it dominates, so it’s a potential way to free memory.（从根源消灭问题）


## 动态跟踪--- Start Allocation Tracking

 
前面我们已经知道，像这样的直接看其实是不容易知道到底是哪里加了内存的！纯粹看下怎样就好了，
上面的点也解释了为何我们要看`Java Heap`的原因了。

我们现在来看下动态的跟踪情况。
我们在发送跳变前先点击下按钮3，大小标记，表示从这里开始跟踪，然后当我们觉得可以的时候再点多一次，表示这次跟踪到这里结束。
**效果如下图所示：**

![enter image description here](http://7xl9zd.com1.z0.glb.clouddn.com/memoryQQ%E6%88%AA%E5%9B%BE20160527174247.png)

然后系统会弹出来一个对话框内容如下

![enter image description here](http://7xl9zd.com1.z0.glb.clouddn.com/memoryQQ%E6%88%AA%E5%9B%BE20160527175659.png)

我们再还是那样，按照右边的Size栏排序，然后一路跟踪下去，发现是 OnBugClick()函数霸占了大部分的空间。如果你点击顶部的**饼状图**的按钮，下面还回出现多一个Panel，可以非常直观的看实际情况！
布局也有多种方式，请自己探索下，效果很绚丽！

在下面的框，当我选中了棕黄色那条时候，右边那一栏显示到了onBugclick()函数，是MainActivity的第196行代码！！！！顶部有显示对应的占用是1.07mb,然后最后面一排非常细小的模块组成的那根柱子，就是我们调用的那几百个对象！是不是很酷的效果！



### 小结


The Allocation Tracker does the following:
	
- Shows when and where your code allocates object types, their size, allocating thread, and stack traces.
- Helps recognize memory churn through recurring allocation/deallocation patterns.
- Helps you track down memory leaks when used in combination with the HPROF Viewer. For example, if you see a bitmap object resident on the heap, you can find its allocation location with Allocation Tracker.
 
## ADB

前面我们看的都是非常细的内容，为我们的某些对象的占用情况，不过关于整体性的，目前的内存占用整体用了多少，我们还可以有多少，什么类型的用得多，快满了要OOM了，需要调节下，我们都没有概念。
所以我们现在需要来对这里做个了解 。




# ref
1. [Android Monitor Overview](https://developer.android.com/studio/profile/android-monitor.html)
2. [HPROF Viewer and Analyzer](https://developer.android.com/studio/profile/am-hprof.html)
3. [Allocation Tracker](https://developer.android.com/studio/profile/am-allocation.html)
4.  [Managing Your App's Memory](https://developer.android.com/training/articles/memory.html) 